<div class="blog-article">
    <h1><a href="p.html?p=算法/算法之数组中只出现一次的数字" class="title">算法之数组中只出现一次的数字</a></h1>
    <span class="author">xiashuobad</span>
    <span class="time">2018-07-07 11:02</span>
    <span><a href="tags.html?t=算法" class="tag">算法</a></span>
    </div>
<br/>

## 题目描述 ##
> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
## 思路1 ##
1. 首先想到的方法肯定是用哈希，时间复杂度小
2. 先遍历一遍数组，统计所有数字的个数，存入字典（哈希）中
3. 再遍历一遍字典，返回个数为为1的数字
4. 时间复杂度为o(n)

## python实现 ##
```python
class Solution:
    def FindNumsAppearOnce(self, array):
        dict_count = {}
        results = []
        for val in array:
            dict_count[val] = dict_count.get(val, 0) + 1
        for k,v in dict_count.items():
            if v == 1:
                results.append(k)
        return results

```

## 思路2 ##
1. 看的比较多的一种方法，利用异或。
2. 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，
其他的数字都出现了两次。 请写程序找出这个只出现一次的数字。这个题目的突破口在哪里？
题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：
任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，
那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。
3. 有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。
在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，
按照前面的办法就是分别求出这两个只出现一次的数字了。
4. 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次
的数字的异或结果。
5. 因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，
那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1。
我们在结果数字中找到第一个为1 的位的位置，记为第N 位。
6. 现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，
第一个子数组中每个数字的第N位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
7. 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，
而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。
## python实现 ##
```python
#这个代码在本机上测试没有问题，测试用例都能过，但是在牛客网上却运行结果不同，暂时搞不清楚原因。
class Solution2:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        sum=0
        num1,num2=0,0
        for val in array:
            sum ^=val
        index=0
        while sum ^ 1==0:
            sum=sum >> 1
            index +=1
        for val in array:
            if val & (1<<index)==0:
                num1 ^=val
            else:
                num2 ^=val
        return [num1,num2]
```