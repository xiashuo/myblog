<div class="blog-article">
    <h1><a href="p.html?p=算法/算法之数组中只出现一次的数字" class="title">算法之数组中只出现一次的数字</a></h1>
    <span class="author">xiashuobad</span>
    <span class="time">2018-07-07 11:02</span>
    <span><a href="tags.html?t=算法" class="tag">算法</a></span>
    </div>
<br/>

## 题目描述 ##
> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
## 思路1 ##
1. 首先想到的方法是，将数组先排序，然后从左到右遍历数组。

初试下标i=0，如果a[i]=a[i+1],则i=i+2，否则的话，则说明找到一个满足值，添加到返回列表res中，然后令i+=1。

当找到两个满足条件的值后，即len（res）=2时，可以提前终止循环。

需要注意的是循环的上届为倒数第二个元素，所以最后需要判断i的值是否为最后一个索引值

如果是，则说明最后一个值满足条件，加入到res中

最后返回res
## python实现 ##
	# -*- coding:utf-8 -*-
	class Solution:
	    # 返回[a,b] 其中ab是出现一次的两个数字
	    def FindNumsAppearOnce(self, array):
	        array.sort()
	        res=[]
	        i=0
	        while i<len(array)-1:
	            if array[i]!=array[i+1]:
	                res.append(array[i])
	                i+=1
	                if len(res)==2:
	                    break
	            else:
	                i+=2
	        return res

## 思路2 ##
看的比较多的一种方法，利用异或。

 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。

 请写程序找出这个只出现一次的数字。这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。

有了上面简单问题的解决方案之后，我们回到原始的问题。

 如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。
 如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。

 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。

 因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，
 也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。
 现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，
 而第二个子数组的每个数字的第N 位都为0 。

 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，
 而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。
## python实现 ##
	#这个代码在本机上测试没有问题，测试用例都能过，但是在牛客网上却运行结果不同，暂时搞不清楚原因。
	class Solution2:
	    # 返回[a,b] 其中ab是出现一次的两个数字
	    def FindNumsAppearOnce(self, array):
	        sum=0
	        num1,num2=0,0
	        for val in array:
	            sum ^=val
	        index=0
	        while sum ^ 1==0:
	            sum=sum >> 1
	            index +=1
	        for val in array:
	            if val & (1<<index)==0:
	                num1 ^=val
	            else:
	                num2 ^=val
	        return [num1,num2]